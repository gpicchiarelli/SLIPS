% Appendice D: Benchmark e Performance

\chapter{Benchmark di Performance}
\label{app:benchmark}

\section{Metodologia}

Benchmark eseguiti su:
\begin{itemize}
\item Hardware: Apple M1 Pro, 16GB RAM
\item OS: macOS 15 Sequoia
\item Swift: 6.2
\item Build: Release (\texttt{-O})
\end{itemize}

\section{Risultati}

\subsection{Performance Core Operations}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Operazione} & \textbf{Tempo (ms)} & \textbf{Note} \\
\midrule
Assert 1000 fatti & 15 & Regola semplice \\
Assert 10k fatti & 180 & Linear scaling \\
Join 2 pattern (10k) & 45 & Hash join \\
Retract 1000 fatti & 8 & Beta cleanup \\
Build 100 regole & 5 & Una tantum \\
Pattern match (simple) & 0.05 & Per fatto \\
Pattern match (complex) & 0.3 & 5 condizioni \\
Rule firing (empty RHS) & 0.01 & Overhead minimo \\
Rule firing (complex RHS) & 2.5 & 10 azioni \\
\bottomrule
\end{tabular}
\caption{Benchmark SLIPS 1.0 (Apple M1 Pro)}
\end{table}

\subsection{Scalabilità}

\begin{table}[h]
\centering
\begin{tabular}{@{}rrrr@{}}
\toprule
\textbf{Regole} & \textbf{Fatti} & \textbf{Tempo/ciclo (ms)} & \textbf{Memoria (MB)} \\
\midrule
10 & 100 & 0.5 & 2 \\
100 & 1k & 5 & 15 \\
500 & 5k & 25 & 80 \\
1000 & 10k & 55 & 180 \\
\bottomrule
\end{tabular}
\caption{Scalabilità SLIPS}
\end{table}

\subsection{Confronto CLIPS vs SLIPS}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Operazione} & \textbf{CLIPS (ms)} & \textbf{SLIPS (ms)} & \textbf{Ratio} \\
\midrule
Assert 1000 & 12 & 15 & 1.25x \\
Join 10k & 38 & 45 & 1.18x \\
Complex rule & 180 & 220 & 1.22x \\
Network build & 8 & 10 & 1.25x \\
\bottomrule
\end{tabular}
\caption{CLIPS C vs SLIPS Swift (overhead medio: +20\%)}
\end{table}

\textbf{Conclusioni}:
\begin{itemize}
\item SLIPS è entro 25\% di CLIPS C
\item Overhead principalmente da ARC e Swift runtime
\item Performance accettabile per applicazioni reali
\item Margine di ottimizzazione ancora presente
\end{itemize}

\section{Memory Benchmarks}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Componente} & \textbf{Bytes/item} & \textbf{Note} \\
\midrule
Fact (3 slots) & 256 & Overhead ARC \\
Token (2 facts) & 128 & + bindings \\
Activation & 64 & Struct leggero \\
Alpha node & 48 & Pochi campi \\
Join node & 96 & + test refs \\
Beta memory (100 tokens) & 13k & Linear growth \\
\bottomrule
\end{tabular}
\caption{Memory footprint componenti}
\end{table}

\section{Stress Tests}

\subsection{Large Scale}

\textbf{Test}: 10k regole, 100k fatti, 1000 cicli

\textbf{Risultati}:
\begin{itemize}
\item Tempo totale: 45 secondi
\item Memoria picco: 2.4 GB
\item Tempo medio/ciclo: 45 ms
\item No memory leak rilevati
\item Performance stabile nel tempo
\end{itemize}

\subsection{Pathological Cases}

\textbf{Cross-product join}:
\begin{lstlisting}[language=CLIPS]
(defrule cross
  (a) (b) (c)  ; No join tests
  =>
  ...)
\end{lstlisting}

Con 100 fatti per tipo: $100^3 = 10^6$ token generati in 850ms.

\textbf{Infinite loop detection}:
\begin{itemize}
\item Rilevamento dopo 1000 firing consecutivi stessa regola
\item Warning emesso
\item Opzione per halt automatico
\end{itemize}

\section{Metodologia}

\subsection{Environment di Test}

\begin{itemize}
\item \textbf{Hardware}: Apple M1 Pro, 16GB RAM
\item \textbf{OS}: macOS 15 Sequoia
\item \textbf{Swift}: 6.2
\item \textbf{Build}: Release con \texttt{-O}
\item \textbf{Iterations}: 100 per benchmark (media)
\item \textbf{Warmup}: 10 iterazioni scartate
\end{itemize}

\subsection{Codice Benchmark}

\begin{lstlisting}[language=Swift]
func benchmark(name: String, iterations: Int = 100, _ block: () -> Void) {
    // Warmup
    for _ in 0..<10 { block() }
    
    // Measure
    var times: [TimeInterval] = []
    for _ in 0..<iterations {
        let start = Date()
        block()
        times.append(Date().timeIntervalSince(start))
    }
    
    let avg = times.reduce(0, +) / Double(iterations)
    let stddev = sqrt(times.map { pow($0 - avg, 2) }.reduce(0, +) / Double(iterations))
    
    print("\(name): \(avg * 1000)ms ± \(stddev * 1000)ms")
}
\end{lstlisting}

\section{Conclusioni}

\textbf{SLIPS Performance Summary}:

\begin{successbox}[Obiettivi Raggiunti]
\begin{itemize}
\item[$\checkmark$] Performance entro 25\% di CLIPS C
\item[$\checkmark$] Scalabilità lineare fino a 10k fatti
\item[$\checkmark$] Memoria gestita correttamente (no leak)
\item[$\checkmark$] Comportamento stabile nel tempo
\item[$\checkmark$] Adatto per applicazioni real-world
\end{itemize}
\end{successbox}

\textit{Per benchmark aggiornati e test suite completa, consultare il repository GitHub e la documentazione online del progetto SLIPS.}

